[
  {
    "id": 25,
    "question": "What is Angular?",
    "answer": "<p>Angular is a front-end web framework made by Google to build <strong>single-page web applications (SPA)</strong> using <strong>HTML, CSS, and TypeScript</strong>.</p>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 26,
    "question": "What is a component in Angular?",
    "answer": "<p>A component is the basic building block of an Angular application. It controls a part of the screen called a <strong>view</strong>.</p><pre><code>@Component({\n  selector: 'app-hello',\n  template: '<h1>Hello World!</h1>'\n})\nexport class HelloComponent { }</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 27,
    "question": "What is a module in Angular?",
    "answer": "<p>A module is a container that holds related components, services, and other modules. Every Angular app has a root module called <code>AppModule</code>.</p><pre><code>@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 28,
    "question": "What is data binding?",
    "answer": "<p>Data binding is the connection between the HTML and the component (TypeScript code). It helps keep your UI and logic in sync.</p><p><strong>Types:</strong></p><ul><li><strong>Interpolation</strong> – <code>{{ name }}</code></li><li><strong>Property binding</strong> – <code>[src]=\"imageUrl\"</code></li><li><strong>Event binding</strong> – <code>(click)=\"sayHello()\"</code></li><li><strong>Two-way binding</strong> – <code>[(ngModel)]=\"userInput\"</code></li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 29,
    "question": "What is dependency injection?",
    "answer": "<p>Dependency injection is a design pattern used to provide services (like APIs, logic, etc.) to components automatically.</p><pre><code>constructor(private userService: UserService) { }</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 30,
    "question": "What is a service in Angular?",
    "answer": "<p>A service is a class used to write business logic, such as fetching data from an API. It can be shared across multiple components.</p><pre><code>@Injectable({ providedIn: 'root' })\nexport class ApiService {\n  getData() {\n    return this.http.get('/api/data');\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 31,
    "question": "What is routing in Angular?",
    "answer": "<p>Routing is how Angular navigates between different pages or views in a single-page app.</p><pre><code>const routes: Routes = [\n  { path: 'home', component: HomeComponent },\n  { path: 'about', component: AboutComponent }\n];</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 32,
    "question": "What are directives?",
    "answer": "<p>Directives are instructions in the template that tell Angular how to render or change elements.</p><p><strong>Types:</strong></p><ul><li><strong>Structural</strong> – <code>*ngIf</code>, <code>*ngFor</code></li><li><strong>Attribute</strong> – <code>[ngClass]</code>, <code>[ngStyle]</code></li><li><strong>Custom</strong> – You can create your own directive.</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 33,
    "question": "What is the difference between ngIf and ngFor?",
    "answer": "<ul><li><code>*ngIf</code> is used to <strong>show or hide</strong> an element.</li><li><code>*ngFor</code> is used to <strong>loop through a list</strong> and create multiple elements.</li></ul><pre><code><p *ngIf=\"isLoggedIn\">Welcome!</p>\n<ul>\n  <li *ngFor=\"let item of items\">{{ item }}</li>\n</ul></code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 34,
    "question": "What is a pipe in Angular?",
    "answer": "<p>Pipes are used to transform data in the template</p><pre><code><p>{{ birthday | date:'longDate' }}</p>\n<p>{{ price | currency:'USD' }}</p></code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 35,
    "question": "What is the difference between @Input() and @Output()?",
    "answer": "<ul><li><code>@Input()</code> – Pass data <strong>from parent to child</strong> component.</li><li><code>@Output()</code> – Send data <strong>from child to parent</strong> component using <code>EventEmitter</code>.</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 36,
    "question": "What is lazy loading?",
    "answer": "<p>Lazy loading means loading a module <strong>only when it's needed</strong>, not at the start. It helps improve performance.</p>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 37,
    "question": "What is Angular CLI?",
    "answer": "<p>Angular CLI is a command-line tool to create and manage Angular apps.</p><p><strong>Example commands:</strong></p><ul><li><code>ng new my-app</code> – create a new app</li><li><code>ng serve</code> – run the app</li><li><code>ng generate component header</code> – create a component</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 38,
    "question": "How do you share data between components?",
    "answer": "<ul><li><strong>Parent to Child</strong> – use <code>@Input()</code></li><li><strong>Child to Parent</strong> – use <code>@Output()</code></li><li><strong>Sibling components</strong> – use a <strong>shared service</strong></li><li><strong>Across app</strong> – use <strong>NgRx</strong> or shared services</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 39,
    "question": "What is Ahead-of-Time (AOT) Compilation?",
    "answer": "<p>Angular offers two types of compilation:</p><ul><li><strong>JIT (Just-in-Time):</strong> Compiles in the browser (during development)</li><li><strong>AOT (Ahead-of-Time):</strong> Compiles during build time (for production)</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 40,
    "question": "What are lifecycle hooks in Angular?",
    "answer": "<p>Lifecycle hooks are special methods Angular calls at different stages of a component's life — from creation to destruction.</p><ul><li><code>constructor</code>When the component is created (used for simple setup)</li><li><code>ngOnChanges()</code>When an input property changes</li><li><code>ngOnInit()</code>After the first <code>ngOnChanges</code> – good for API calls</li><li><code>ngDoCheck()</code>Custom change detection (called often)</li><li><code>ngAfterContentInit()</code>After external content is projected into the component</li><li><code>ngAfterContentChecked()</code>After every check of projected content</li><li><code>ngAfterViewInit()</code>After component view (and child views) are initialized</li><li><code>ngAfterViewChecked()</code>After every check of the component and child views</li><li><code>ngOnDestroy()</code>Just before the component is destroyed – cleanup time</li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 41,
    "question": "What is the difference between Observable and Promise?",
    "answer": "<p><strong>Observable</strong></p><ul><li>Can emit <strong>multiple values</strong></li><li>it can be <strong>Cancelable</strong></li><li>its <strong>Lazy </strong>(runs only when subscribed)</li></ul><p><strong>Promise</strong></p><ul><li>Emits <strong>one value</strong> only</li><li>it can not be <strong>Cancelable</strong></li><li>its <strong>Lazy</strong></li></ul>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 44,
    "question": "What is Angular's change detection?",
    "answer": "<p>Change detection is how Angular keeps track of changes in your app and updates the view. Think of it like a security camera that watches for changes and updates the screen when needed.</p><pre><code>@Component({\n  selector: 'app-counter',\n  template: `\n    <button (click)=\"increment()\">Count: {{count}}</button>\n  `\n})\nexport class CounterComponent {\n  count = 0;\n  increment() {\n    this.count++; // Angular automatically updates the view\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 45,
    "question": "What is Angular's HttpClient and how to use it?",
    "answer": "<p>HttpClient is a service for making HTTP requests (like getting data from a server). It's like a messenger that fetches or sends data.</p><pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  constructor(private http: HttpClient) {}\n\n  // Get users from server\n  getUsers() {\n    return this.http.get('https://api.example.com/users');\n  }\n\n  // Add a new user\n  addUser(user: any) {\n    return this.http.post('https://api.example.com/users', user);\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 46,
    "question": "What is Angular's async pipe?",
    "answer": "<p>The async pipe automatically handles subscriptions and unsubscriptions for Observables and Promises. It's like having an automatic cleanup crew.</p><pre><code>@Component({\n  selector: 'app-users',\n  template: `\n    <div *ngIf=\"users$ | async as users\">\n      <ul>\n        <li *ngFor=\"let user of users\">\n          {{user.name}}\n        </li>\n      </ul>\n    </div>\n  `\n})\nexport class UsersComponent {\n  users$ = this.userService.getUsers();\n  constructor(private userService: UserService) {}\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 47,
    "question": "What is Angular's ViewChild and how to use it?",
    "answer": "<p>ViewChild lets you access child components, directives, or DOM elements from your parent component. It's like having a remote control for child elements.</p><pre><code>@Component({\n  selector: 'app-parent',\n  template: `\n    <app-child #childRef></app-child>\n    <button (click)=\"callChildMethod()\">Call Child</button>\n  `\n})\nexport class ParentComponent {\n  @ViewChild('childRef') child: ChildComponent;\n\n  callChildMethod() {\n    this.child.someMethod(); // Call child's method\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 48,
    "question": "What is Angular's form validation?",
    "answer": "<p>Form validation helps ensure users enter correct data. Angular provides built-in validators and lets you create custom ones.</p><pre><code>@Component({\n  selector: 'app-login',\n  template: `\n    <form [formGroup]=\"loginForm\" (ngSubmit)=\"onSubmit()\">\n      <input formControlName=\"email\" placeholder=\"Email\">\n      <div *ngIf=\"email.invalid && email.touched\">\n        Email is required and must be valid\n      </div>\n\n      <input type=\"password\" formControlName=\"password\">\n      <div *ngIf=\"password.invalid && password.touched\">\n        Password must be at least 6 characters\n      </div>\n\n      <button [disabled]=\"loginForm.invalid\">Login</button>\n    </form>\n  `\n})\nexport class LoginComponent {\n  loginForm = this.fb.group({\n    email: ['', [Validators.required, Validators.email]],\n    password: ['', [Validators.required, Validators.minLength(6)]]\n  });\n\n  constructor(private fb: FormBuilder) {}\n\n  get email() { return this.loginForm.get('email'); }\n  get password() { return this.loginForm.get('password'); }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 101,
    "question": "What is Dependency Injection (DI) in Angular and how does it work?",
    "answer": "<p>Dependency Injection is a design pattern where a class receives its dependencies from external sources rather than creating them itself. Angular has a built-in DI system.</p><h3>Basic Example:</h3><pre><code>// Service\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  constructor() {}\n  getUsers() {\n    return ['John', 'Jane'];\n  }\n}\n\n// Component using the service\n@Component({\n  selector: 'app-users',\n  template: '...'\n})\nexport class UsersComponent {\n  constructor(private userService: UserService) {}\n  \n  ngOnInit() {\n    const users = this.userService.getUsers();\n  }\n}</code></pre><h3>Different Ways to Provide Services:</h3><pre><code>// 1. Root level (singleton)\n@Injectable({\n  providedIn: 'root'\n})\n\n// 2. Module level\n@NgModule({\n  providers: [UserService]\n})\n\n// 3. Component level\n@Component({\n  providers: [UserService]\n})</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 102,
    "question": "What is the difference between ngOnInit and constructor in Angular?",
    "answer": "<p>The constructor and ngOnInit serve different purposes in Angular components.</p><h3>Constructor:</h3><ul><li>Called when the class is instantiated</li><li>Used for dependency injection</li><li>Should only be used to initialize class members</li></ul><h3>ngOnInit:</h3><ul><li>Called after the constructor</li><li>Called after Angular has initialized all data-bound properties</li><li>Best place to put initialization logic</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit {\n  // Constructor - for DI only\n  constructor(\n    private userService: UserService,\n    private router: Router\n  ) {}\n\n  // ngOnInit - for initialization\n  ngOnInit() {\n    // Safe to access @Input properties\n    // Safe to make HTTP calls\n    // Safe to initialize component state\n    this.loadData();\n  }\n\n  private loadData() {\n    this.userService.getData().subscribe(data => {\n      // Handle data\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 103,
    "question": "What is the difference between BehaviorSubject and Subject in RxJS?",
    "answer": "<p>BehaviorSubject and Subject are both types of Observables in RxJS, but they have key differences in how they handle data.</p><h3>Subject:</h3><ul><li>Doesn't store the last value</li><li>Subscribers only receive values emitted after they subscribe</li></ul><h3>BehaviorSubject:</h3><ul><li>Stores the last value</li><li>New subscribers receive the last emitted value immediately</li><li>Requires an initial value</li></ul><h3>Example:</h3><pre><code>// Subject Example\nconst subject = new Subject<number>();\nsubject.next(1);\nsubject.next(2);\n\nsubject.subscribe(value => {\n  console.log('Subject:', value); // Only receives 3\n});\nsubject.next(3);\n\n// BehaviorSubject Example\nconst behaviorSubject = new BehaviorSubject<number>(0);\nbehaviorSubject.next(1);\nbehaviorSubject.next(2);\n\nbehaviorSubject.subscribe(value => {\n  console.log('BehaviorSubject:', value); // Receives 2 immediately, then 3\n});\nbehaviorSubject.next(3);</code></pre><h3>Real-world Example:</h3><pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  private userSubject = new BehaviorSubject<User | null>(null);\n  user$ = this.userSubject.asObservable();\n\n  setUser(user: User) {\n    this.userSubject.next(user);\n  }\n\n  getUser() {\n    return this.userSubject.value;\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 104,
    "question": "What is Change Detection in Angular and how does it work?",
    "answer": "<p>Change Detection is Angular's mechanism to detect changes in the application state and update the view accordingly.</p><h3>How it Works:</h3><ul><li>Angular creates a change detector for each component</li><li>Checks for changes in component properties</li><li>Updates the view if changes are detected</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-counter',\n  template: `\n    <p>Count: {{ count }}</p>\n    <button (click)='increment()'>Increment</button>\n  `\n})\nexport class CounterComponent {\n  count = 0;\n\n  increment() {\n    this.count++; // Triggers change detection\n  }\n}</code></pre><h3>Change Detection Strategies:</h3><pre><code>// Default strategy (CheckAlways)\n@Component({\n  selector: 'app-default',\n  template: '...'\n})\nexport class DefaultComponent {}\n\n// OnPush strategy\n@Component({\n  selector: 'app-onpush',\n  template: '...',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class OnPushComponent {}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 105,
    "question": "What is NgModule in Angular and what are its main properties?",
    "answer": "<p>NgModule is a decorator that marks a class as an Angular module. It helps organize the application into cohesive blocks of functionality.</p><h3>Main Properties:</h3><ul><li>declarations: Components, directives, and pipes</li><li>imports: Other modules</li><li>providers: Services</li><li>exports: Components, directives, and pipes to be used in other modules</li><li>bootstrap: Root component</li></ul><h3>Example:</h3><pre><code>@NgModule({\n  declarations: [\n    AppComponent,\n    UserComponent,\n    UserListComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    RouterModule\n  ],\n  providers: [\n    UserService,\n    AuthService\n  ],\n  exports: [\n    UserComponent\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }</code></pre><h3>Feature Module Example:</h3><pre><code>@NgModule({\n  declarations: [\n    UserListComponent,\n    UserDetailComponent\n  ],\n  imports: [\n    CommonModule,\n    RouterModule.forChild(userRoutes)\n  ],\n  providers: [UserService]\n})\nexport class UserModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 106,
    "question": "What is the difference between RouterModule.forRoot() and RouterModule.forChild()?",
    "answer": "<p>RouterModule.forRoot() and RouterModule.forChild() are used to configure routing in Angular applications, but they serve different purposes.</p><h3>RouterModule.forRoot():</h3><ul><li>Used in the root module</li><li>Configures the router service</li><li>Should be used only once in the application</li></ul><h3>RouterModule.forChild():</h3><ul><li>Used in feature modules</li><li>Adds additional routes to the existing configuration</li><li>Can be used multiple times</li></ul><h3>Example:</h3><pre><code>// app.module.ts (Root Module)\n@NgModule({\n  imports: [\n    RouterModule.forRoot([\n      { path: '', component: HomeComponent },\n      { path: 'about', component: AboutComponent }\n    ])\n  ]\n})\nexport class AppModule { }\n\n// user.module.ts (Feature Module)\n@NgModule({\n  imports: [\n    RouterModule.forChild([\n      { path: 'users', component: UserListComponent },\n      { path: 'users/:id', component: UserDetailComponent }\n    ])\n  ]\n})\nexport class UserModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 107,
    "question": "What is NgZone in Angular and when should you use it?",
    "answer": "<p>NgZone is a service that helps Angular detect changes by wrapping asynchronous operations. It's useful when working with code outside Angular's zone.</p><h3>Basic Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent {\n  constructor(private ngZone: NgZone) {}\n\n  // Inside Angular zone (default)\n  insideZone() {\n    setTimeout(() => {\n      // This will trigger change detection\n      this.value = 'Updated';\n    }, 1000);\n  }\n\n  // Outside Angular zone\n  outsideZone() {\n    this.ngZone.runOutsideAngular(() => {\n      setTimeout(() => {\n        // This won't trigger change detection\n        this.value = 'Updated';\n        // Manually trigger change detection if needed\n        this.ngZone.run(() => {\n          // Now change detection will run\n        });\n      }, 1000);\n    });\n  }\n}</code></pre><h3>Real-world Example (Performance Optimization):</h3><pre><code>@Component({\n  selector: 'app-chart',\n  template: '...'\n})\nexport class ChartComponent {\n  constructor(private ngZone: NgZone) {}\n\n  initChart() {\n    this.ngZone.runOutsideAngular(() => {\n      // Heavy chart initialization\n      this.chart = new Chart(/* ... */);\n      \n      // Update chart data without triggering change detection\n      this.chart.update();\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 108,
    "question": "What are Guards in Angular and what are their types?",
    "answer": "<p>Guards are interfaces that control access to routes in Angular. They help protect routes from unauthorized access.</p><h3>Types of Guards:</h3><ul><li>CanActivate: Controls if a route can be activated</li><li>CanDeactivate: Controls if a user can leave a route</li><li>Resolve: Resolves data before activating a route</li><li>CanActivateChild: Controls access to child routes</li><li>CanMatch: Controls if a route can be matched</li></ul><h3>Example:</h3><pre><code>// Auth Guard\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  constructor(\n    private authService: AuthService,\n    private router: Router\n  ) {}\n\n  canActivate(): boolean {\n    if (this.authService.isAuthenticated()) {\n      return true;\n    }\n    this.router.navigate(['/login']);\n    return false;\n  }\n}\n\n// Using the guard in routes\nconst routes: Routes = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    canActivate: [AuthGuard]\n  }\n];</code></pre><h3>Deactivate Guard Example:</h3><pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class DeactivateGuard implements CanDeactivate<EditComponent> {\n  canDeactivate(\n    component: EditComponent\n  ): boolean | Observable<boolean> {\n    if (component.hasUnsavedChanges()) {\n      return confirm('You have unsaved changes. Leave anyway?');\n    }\n    return true;\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 109,
    "question": "What is a Resolver in Angular and how does it work?",
    "answer": "<p>A Resolver is a service that resolves data before a route is activated. It ensures that data is available before the component is displayed.</p><h3>Basic Example:</h3><pre><code>@Injectable({\n  providedIn: 'root'\n})\nexport class UserResolver implements Resolve<User> {\n  constructor(private userService: UserService) {}\n\n  resolve(\n    route: ActivatedRouteSnapshot\n  ): Observable<User> | Promise<User> | User {\n    const userId = route.paramMap.get('id');\n    return this.userService.getUser(userId);\n  }\n}\n\n// Using the resolver in routes\nconst routes: Routes = [\n  {\n    path: 'user/:id',\n    component: UserComponent,\n    resolve: {\n      user: UserResolver\n    }\n  }\n];\n\n// Accessing resolved data in component\n@Component({\n  selector: 'app-user',\n  template: '...'\n})\nexport class UserComponent implements OnInit {\n  constructor(private route: ActivatedRoute) {}\n\n  ngOnInit() {\n    this.route.data.subscribe(data => {\n      const user = data['user'];\n      // Use the resolved data\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 110,
    "question": "What are Dynamic Components in Angular and how do you create them?",
    "answer": "<p>Dynamic Components are components that are created and added to the DOM at runtime. They're useful for creating flexible UIs.</p><h3>Example:</h3><pre><code>// Dynamic component\n@Component({\n  selector: 'app-alert',\n  template: `\n    <div class='alert'>\n      <h2>{{ message }}</h2>\n      <button (click)='close()'>Close</button>\n    </div>\n  `\n})\nexport class AlertComponent {\n  @Input() message: string;\n  @Output() close = new EventEmitter<void>();\n}\n\n// Component that creates dynamic components\n@Component({\n  selector: 'app-container',\n  template: '<div #alertContainer></div>'\n})\nexport class ContainerComponent {\n  @ViewChild('alertContainer', { read: ViewContainerRef })\n  container: ViewContainerRef;\n\n  constructor(private componentFactoryResolver: ComponentFactoryResolver) {}\n\n  createAlert(message: string) {\n    // Clear previous alerts\n    this.container.clear();\n\n    // Create component\n    const factory = this.componentFactoryResolver\n      .resolveComponentFactory(AlertComponent);\n    const componentRef = this.container.createComponent(factory);\n\n    // Set inputs\n    componentRef.instance.message = message;\n\n    // Handle outputs\n    componentRef.instance.close.subscribe(() => {\n      componentRef.destroy();\n    });\n  }\n}</code></pre><h3>Using the Dynamic Component:</h3><pre><code>// In the module\n@NgModule({\n  declarations: [AlertComponent],\n  entryComponents: [AlertComponent]\n})\nexport class AppModule { }\n\n// In the template\n<button (click)='createAlert(\"Hello!\")'>Show Alert</button></code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 111,
    "question": "What is Module Federation in Angular and how does it work?",
    "answer": "<p>Module Federation is a feature that allows you to dynamically load modules from different applications at runtime. It's useful for micro-frontend architectures.</p><h3>Basic Setup:</h3><pre><code>// webpack.config.js (Host Application)\nconst ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin');\n\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',\n      remotes: {\n        mfe1: 'mfe1@http://localhost:3000/remoteEntry.js'\n      },\n      shared: ['@angular/core', '@angular/common']\n    })\n  ]\n};\n\n// webpack.config.js (Remote Application)\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'mfe1',\n      filename: 'remoteEntry.js',\n      exposes: {\n        './Component': './src/app/component'\n      },\n      shared: ['@angular/core', '@angular/common']\n    })\n  ]\n};</code></pre><h3>Using Remote Components:</h3><pre><code>// app.module.ts\n@NgModule({\n  imports: [\n    RouterModule.forRoot([\n      {\n        path: 'mfe1',\n        loadChildren: () => import('mfe1/Component')\n      }\n    ])\n  ]\n})\nexport class AppModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 112,
    "question": "What is the difference between ng-template, ng-container, and ng-content?",
    "answer": "<p>These three directives serve different purposes in Angular templates.</p><h3>ng-template:</h3><ul><li>Defines a template that can be reused</li><li>Not rendered by default</li><li>Used with structural directives</li></ul><h3>ng-container:</h3><ul><li>Grouping element that doesn't add to the DOM</li><li>Useful for applying multiple structural directives</li></ul><h3>ng-content:</h3><ul><li>Projects content from parent to child</li><li>Used for content projection</li></ul><h3>Examples:</h3><pre><code>// ng-template example\n<ng-template #loading>\n  <div>Loading...</div>\n</ng-template>\n\n<div *ngIf='isLoading; else loading'>\n  Content\n</div>\n\n// ng-container example\n<ng-container *ngIf='isLoggedIn'>\n  <div>Welcome</div>\n  <div>Profile</div>\n</ng-container>\n\n// ng-content example\n// parent.component.html\n<app-card>\n  <h1>Title</h1>\n  <p>Content</p>\n</app-card>\n\n// card.component.html\n<div class='card'>\n  <ng-content></ng-content>\n</div></code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 113,
    "question": "What is the difference between ViewChild and ContentChild?",
    "answer": "<p>ViewChild and ContentChild are decorators used to access child elements, but they work in different contexts.</p><h3>ViewChild:</h3><ul><li>Accesses elements in the component's view</li><li>Available after view initialization</li></ul><h3>ContentChild:</h3><ul><li>Accesses projected content</li><li>Available after content initialization</li></ul><h3>Example:</h3><pre><code>// Parent Component\n@Component({\n  selector: 'app-parent',\n  template: `\n    <div #viewChild>View Child</div>\n    <app-child>\n      <div #contentChild>Content Child</div>\n    </app-child>\n  `\n})\nexport class ParentComponent implements AfterViewInit, AfterContentInit {\n  @ViewChild('viewChild') viewChild: ElementRef;\n  @ContentChild('contentChild') contentChild: ElementRef;\n\n  ngAfterViewInit() {\n    // ViewChild is available here\n    console.log(this.viewChild);\n  }\n\n  ngAfterContentInit() {\n    // ContentChild is available here\n    console.log(this.contentChild);\n  }\n}\n\n// Child Component\n@Component({\n  selector: 'app-child',\n  template: '<ng-content></ng-content>'\n})\nexport class ChildComponent {}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 114,
    "question": "What is OnPush Change Detection and when should you use it?",
    "answer": "<p>OnPush is a change detection strategy that improves performance by only checking for changes when inputs change or events occur.</p><h3>Basic Example:</h3><pre><code>@Component({\n  selector: 'app-user',\n  template: `\n    <div>{{ user.name }}</div>\n    <div>{{ user.email }}</div>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class UserComponent {\n  @Input() user: User;\n\n  // Change detection will run when:\n  // 1. @Input() properties change\n  // 2. Events occur in the template\n  // 3. Observable emits in the template\n  // 4. ChangeDetectorRef.detectChanges() is called\n}</code></pre><h3>Working with OnPush:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class ExampleComponent {\n  constructor(\n    private cdr: ChangeDetectorRef,\n    private userService: UserService\n  ) {}\n\n  updateUser() {\n    this.userService.getUser().subscribe(user => {\n      this.user = user;\n      // Manually trigger change detection\n      this.cdr.detectChanges();\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 115,
    "question": "How do you handle memory leaks in Angular?",
    "answer": "<p>Memory leaks in Angular often occur due to unmanaged subscriptions and event listeners. Here are common solutions.</p><h3>Common Causes and Solutions:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    // Using takeUntil\n    this.userService.getUsers()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(users => {\n        // Handle users\n      });\n\n    // Using async pipe (preferred)\n    this.users$ = this.userService.getUsers();\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}</code></pre><h3>Template Example:</h3><pre><code>// Using async pipe (automatically handles subscription)\n<ng-container *ngIf='users$ | async as users'>\n  <div *ngFor='let user of users'>\n    {{ user.name }}\n  </div>\n</ng-container></code></pre><h3>Event Listener Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit, OnDestroy {\n  private resizeListener: () => void;\n\n  ngOnInit() {\n    this.resizeListener = () => {\n      // Handle resize\n    };\n    window.addEventListener('resize', this.resizeListener);\n  }\n\n  ngOnDestroy() {\n    window.removeEventListener('resize', this.resizeListener);\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 116,
    "question": "What are Standalone Components in Angular?",
    "answer": "<p>Standalone Components are a new feature in Angular that allows you to create components without declaring them in an NgModule.</p><h3>Basic Example:</h3><pre><code>@Component({\n  selector: 'app-standalone',\n  template: '...',\n  standalone: true,\n  imports: [CommonModule, RouterModule]\n})\nexport class StandaloneComponent {}\n\n// Using in routes\nconst routes: Routes = [\n  {\n    path: 'standalone',\n    loadComponent: () => import('./standalone.component')\n      .then(m => m.StandaloneComponent)\n  }\n];</code></pre><h3>With Dependencies:</h3><pre><code>@Component({\n  selector: 'app-user-list',\n  template: `\n    <div *ngFor='let user of users$ | async'>\n      {{ user.name }}\n    </div>\n  `,\n  standalone: true,\n  imports: [CommonModule, UserCardComponent],\n  providers: [UserService]\n})\nexport class UserListComponent {\n  users$ = this.userService.getUsers();\n\n  constructor(private userService: UserService) {}\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 117,
    "question": "What is Angular Universal and how do you implement it?",
    "answer": "<p>Angular Universal is a technology that renders Angular applications on the server. It improves performance and SEO.</p><h3>Basic Setup:</h3><pre><code>// app.module.ts\n@NgModule({\n  imports: [\n    BrowserModule.withServerTransition({ appId: 'my-app' }),\n    ServerModule\n  ]\n})\nexport class AppModule { }\n\n// app.server.module.ts\n@NgModule({\n  imports: [\n    AppModule,\n    ServerModule\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppServerModule { }</code></pre><h3>Server-side Rendering Example:</h3><pre><code>// app.component.ts\n@Component({\n  selector: 'app-root',\n  template: `\n    <div>\n      <h1>{{ title }}</h1>\n      <div *ngIf='isBrowser'>Browser only content</div>\n    </div>\n  `\n})\nexport class AppComponent {\n  title = 'My App';\n  isBrowser: boolean;\n\n  constructor(@Inject(PLATFORM_ID) platformId: Object) {\n    this.isBrowser = isPlatformBrowser(platformId);\n  }\n}</code></pre><h3>Running the Application:</h3><pre><code>// package.json\n{\n  \"scripts\": {\n    \"dev:ssr\": \"ng run my-app:serve-ssr\",\n    \"build:ssr\": \"ng build && ng run my-app:server\",\n    \"serve:ssr\": \"node dist/my-app/server/main.js\"\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 118,
    "question": "What are Pipes in Angular and how do you create custom pipes?",
    "answer": "<p>Pipes are used to transform data in templates. Angular provides built-in pipes and allows you to create custom ones.</p><h3>Built-in Pipes Example:</h3><pre><code>// Using built-in pipes\n<div>{{ date | date:'short' }}</div>\n<div>{{ price | currency:'USD' }}</div>\n<div>{{ text | uppercase }}</div>\n<div>{{ items | slice:0:2 }}</div></code></pre><h3>Custom Pipe Example:</h3><pre><code>@Pipe({\n  name: 'truncate'\n})\nexport class TruncatePipe implements PipeTransform {\n  transform(value: string, limit: number = 100): string {\n    if (!value) return '';\n    return value.length > limit\n      ? value.substring(0, limit) + '...'\n      : value;\n  }\n}\n\n// Using the custom pipe\n<div>{{ longText | truncate:50 }}</div></code></pre><h3>Pure vs Impure Pipes:</h3><pre><code>@Pipe({\n  name: 'filter',\n  pure: false // Impure pipe\n})\nexport class FilterPipe implements PipeTransform {\n  transform(items: any[], filter: string): any[] {\n    if (!items || !filter) return items;\n    return items.filter(item =>\n      item.name.toLowerCase().includes(filter.toLowerCase())\n    );\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Beginner"
  },
  {
    "id": 119,
    "question": "What are Angular Lifecycle Hooks and when should you use them?",
    "answer": "<p>Lifecycle hooks are methods that Angular calls at specific points in a component's lifecycle.</p><h3>Common Lifecycle Hooks:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements\n  OnInit,\n  OnDestroy,\n  AfterViewInit,\n  AfterContentInit {\n\n  // Called after data-bound properties are initialized\n  ngOnInit() {\n    // Initialize component\n  }\n\n  // Called before the component is destroyed\n  ngOnDestroy() {\n    // Clean up resources\n  }\n\n  // Called after the view is initialized\n  ngAfterViewInit() {\n    // Access ViewChild\n  }\n\n  // Called after content is projected\n  ngAfterContentInit() {\n    // Access ContentChild\n  }\n\n  // Called when data-bound properties change\n  ngOnChanges(changes: SimpleChanges) {\n    // Handle changes\n  }\n\n  // Called after every change detection run\n  ngDoCheck() {\n    // Custom change detection\n  }\n}</code></pre><h3>Real-world Example:</h3><pre><code>@Component({\n  selector: 'app-user-profile',\n  template: '...'\n})\nexport class UserProfileComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    // Load user data\n    this.userService.getUser()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(user => {\n        // Handle user data\n      });\n  }\n\n  ngOnDestroy() {\n    // Clean up subscriptions\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 120,
    "question": "What is the Injector in Angular and how does it work?",
    "answer": "<p>The Injector is responsible for creating instances of dependencies and maintaining a single instance of each dependency within its scope.</p><h3>Basic Example:</h3><pre><code>// Service\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  constructor() {}\n  getUsers() { return []; }\n}\n\n// Component\n@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent {\n  constructor(private injector: Injector) {\n    // Get service instance\n    const userService = this.injector.get(UserService);\n  }\n}</code></pre><h3>Custom Injector Example:</h3><pre><code>@Component({\n  selector: 'app-parent',\n  template: '...'\n})\nexport class ParentComponent {\n  constructor(private injector: Injector) {}\n\n  createChildComponent() {\n    const childInjector = Injector.create({\n      providers: [\n        { provide: UserService, useClass: MockUserService }\n      ],\n      parent: this.injector\n    });\n\n    const childComponent = createComponent(ChildComponent, {\n      elementInjector: childInjector\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 121,
    "question": "What is trackBy in Angular and why should you use it?",
    "answer": "<p>trackBy is a function used with *ngFor to optimize rendering performance by helping Angular track items in a list.</p><h3>Why Use trackBy:</h3><ul><li>Improves performance with large lists</li><li>Prevents unnecessary DOM updates</li><li>Maintains component state</li></ul><h3>Example:</h3><pre><code>// Without trackBy\n<div *ngFor='let user of users'>\n  {{ user.name }}\n</div>\n\n// With trackBy\n<div *ngFor='let user of users; trackBy: trackByFn'>\n  {{ user.name }}\n</div>\n\n// In component\ntrackByFn(index: number, item: User): number {\n  return item.id; // or any unique identifier\n}</code></pre><h3>Real-world Example:</h3><pre><code>@Component({\n  selector: 'app-user-list',\n  template: `\n    <div *ngFor='let user of users; trackBy: trackByFn'>\n      <app-user-card [user]='user'></app-user-card>\n    </div>\n  `\n})\nexport class UserListComponent {\n  users: User[] = [];\n\n  trackByFn(index: number, user: User): number {\n    return user.id;\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 122,
    "question": "What are Preloading Strategies in Angular and how do they work?",
    "answer": "<p>Preloading strategies determine how Angular loads lazy-loaded modules. They help balance between initial load time and user experience.</p><h3>Types of Preloading Strategies:</h3><ul><li>NoPreloading (default)</li><li>PreloadAllModules</li><li>Custom strategies</li></ul><h3>Example:</h3><pre><code>// Using PreloadAllModules\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, {\n      preloadingStrategy: PreloadAllModules\n    })\n  ]\n})\nexport class AppModule { }\n\n// Custom Preloading Strategy\n@Injectable({\n  providedIn: 'root'\n})\nexport class CustomPreloadingStrategy implements PreloadingStrategy {\n  preload(route: Route, load: () => Observable<any>): Observable<any> {\n    if (route.data && route.data['preload']) {\n      return load();\n    }\n    return of(null);\n  }\n}\n\n// Using custom strategy\nconst routes: Routes = [\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.module'),\n    data: { preload: true }\n  }\n];</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 123,
    "question": "What is the difference between Renderer2 and ElementRef in Angular?",
    "answer": "<p>Renderer2 and ElementRef are both used to manipulate the DOM, but they serve different purposes and have different security implications.</p><h3>ElementRef:</h3><ul><li>Direct access to DOM element</li><li>Less secure</li><li>Should be used carefully</li></ul><h3>Renderer2:</h3><ul><li>Platform-agnostic DOM manipulation</li><li>More secure</li><li>Recommended approach</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '<div #myDiv></div>'\n})\nexport class ExampleComponent {\n  @ViewChild('myDiv') div: ElementRef;\n\n  constructor(private renderer: Renderer2) {}\n\n  // Using ElementRef (not recommended)\n  updateWithElementRef() {\n    this.div.nativeElement.style.backgroundColor = 'red';\n  }\n\n  // Using Renderer2 (recommended)\n  updateWithRenderer() {\n    this.renderer.setStyle(\n      this.div.nativeElement,\n      'backgroundColor',\n      'red'\n    );\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 124,
    "question": "How do you secure an Angular application?",
    "answer": "<p>Securing an Angular application involves multiple layers of protection.</p><h3>Key Security Measures:</h3><ul><li>Use HTTPS</li><li>Implement authentication</li><li>Prevent XSS attacks</li><li>Use Content Security Policy</li><li>Implement proper CORS</li></ul><h3>Example:</h3><pre><code>// HTTP Interceptor for Authentication\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest<any>, next: HttpHandler) {\n    const token = this.authService.getToken();\n    \n    if (token) {\n      const authReq = req.clone({\n        headers: req.headers.set('Authorization', `Bearer ${token}`)\n      });\n      return next.handle(authReq);\n    }\n    return next.handle(req);\n  }\n}\n\n// Content Security Policy\n// index.html\n<meta http-equiv='Content-Security-Policy'\n  content=\"default-src 'self'; script-src 'self' 'unsafe-inline';\">\n\n// Sanitizing user input\n@Component({\n  selector: 'app-example',\n  template: '<div [innerHTML]='sanitizedContent'></div>'\n})\nexport class ExampleComponent {\n  constructor(private sanitizer: DomSanitizer) {}\n\n  sanitizeContent(content: string) {\n    return this.sanitizer.bypassSecurityTrustHtml(content);\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 125,
    "question": "What is a Progressive Web App (PWA) in Angular and how do you implement it?",
    "answer": "<p>A PWA is a web application that can work offline and provide a native app-like experience.</p><h3>Key Features:</h3><ul><li>Offline functionality</li><li>Push notifications</li><li>Installable on devices</li></ul><h3>Implementation:</h3><pre><code>// 1. Add PWA support\nng add @angular/pwa\n\n// 2. Configure manifest.webmanifest\n{\n  \"name\": \"My PWA App\",\n  \"short_name\": \"PWA App\",\n  \"theme_color\": \"#1976d2\",\n  \"background_color\": \"#fafafa\",\n  \"display\": \"standalone\",\n  \"scope\": \"./\",\n  \"start_url\": \"./\",\n  \"icons\": [\n    {\n      \"src\": \"assets/icons/icon-72x72.png\",\n      \"sizes\": \"72x72\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n\n// 3. Service Worker Registration\n// app.module.ts\n@NgModule({\n  imports: [\n    ServiceWorkerModule.register('ngsw-worker.js', {\n      enabled: environment.production\n    })\n  ]\n})\nexport class AppModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 126,
    "question": "What is Tree Shaking in Angular and how does it work?",
    "answer": "<p>Tree shaking is a process that removes unused code from the final bundle, reducing the application size.</p><h3>How it Works:</h3><ul><li>Analyzes code dependencies</li><li>Removes unused exports</li><li>Works with ES modules</li></ul><h3>Example:</h3><pre><code>// This will be included\nimport { Component } from '@angular/core';\n\n// This might be tree-shaken if unused\nimport { unused } from './unused';\n\n@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent {\n  // Only used code is included\n  usedMethod() {\n    // Implementation\n  }\n}\n\n// This will be tree-shaken\nfunction unusedFunction() {\n  // Implementation\n}</code></pre><h3>Best Practices:</h3><pre><code>// Use named exports\n// Good - can be tree-shaken\nexport const used = 'used';\nexport const unused = 'unused';\n\n// Bad - can't be tree-shaken\nexport default {\n  used: 'used',\n  unused: 'unused'\n};</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 127,
    "question": "How do you optimize initial performance in an Angular application?",
    "answer": "<p>Optimizing initial performance involves several strategies to reduce load time and improve user experience.</p><h3>Key Optimization Techniques:</h3><ul><li>Lazy loading</li><li>Preloading strategies</li><li>Bundle optimization</li><li>Server-side rendering</li></ul><h3>Example:</h3><pre><code>// 1. Lazy Loading\nconst routes: Routes = [\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.module')\n  }\n];\n\n// 2. Bundle Optimization\n// angular.json\n{\n  \"optimization\": {\n    \"scripts\": true,\n    \"styles\": true,\n    \"fonts\": true\n  }\n}\n\n// 3. Preloading Strategy\n@NgModule({\n  imports: [\n    RouterModule.forRoot(routes, {\n      preloadingStrategy: PreloadAllModules\n    })\n  ]\n})\nexport class AppModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 128,
    "question": "What is the difference between ActivatedRoute and Router in Angular?",
    "answer": "<p>ActivatedRoute and Router serve different purposes in Angular routing.</p><h3>ActivatedRoute:</h3><ul><li>Accesses route parameters</li><li>Gets route data</li><li>Accesses child routes</li></ul><h3>Router:</h3><ul><li>Navigates between routes</li><li>Manages route configuration</li><li>Handles route events</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit {\n  constructor(\n    private route: ActivatedRoute,\n    private router: Router\n  ) {}\n\n  ngOnInit() {\n    // Using ActivatedRoute\n    this.route.params.subscribe(params => {\n      const id = params['id'];\n    });\n\n    this.route.data.subscribe(data => {\n      const resolvedData = data['resolvedData'];\n    });\n  }\n\n  // Using Router\n  navigateToUser(id: number) {\n    this.router.navigate(['/users', id]);\n  }\n\n  navigateWithQuery() {\n    this.router.navigate(['/users'], {\n      queryParams: { filter: 'active' }\n    });\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 129,
    "question": "What are the different types of Route Guards in Angular?",
    "answer": "<p>Route Guards are interfaces that control access to routes in Angular.</p><h3>Types of Guards:</h3><ul><li>CanActivate</li><li>CanDeactivate</li><li>Resolve</li><li>CanActivateChild</li><li>CanMatch</li></ul><h3>Example:</h3><pre><code>// CanActivate Guard\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthGuard implements CanActivate {\n  canActivate(): boolean {\n    return this.authService.isAuthenticated();\n  }\n}\n\n// CanDeactivate Guard\n@Injectable({\n  providedIn: 'root'\n})\nexport class UnsavedChangesGuard implements CanDeactivate<EditComponent> {\n  canDeactivate(component: EditComponent): boolean {\n    if (component.hasUnsavedChanges()) {\n      return confirm('You have unsaved changes. Leave anyway?');\n    }\n    return true;\n  }\n}\n\n// Resolve Guard\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserResolver implements Resolve<User> {\n  resolve(): Observable<User> {\n    return this.userService.getUser();\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 130,
    "question": "What is Server-Side Rendering (SSR) in Angular and how do you implement it?",
    "answer": "<p>SSR renders Angular applications on the server, improving initial load time and SEO.</p><h3>Implementation:</h3><pre><code>// 1. Add SSR support\nng add @nguniversal/express-engine\n\n// 2. app.server.module.ts\n@NgModule({\n  imports: [\n    AppModule,\n    ServerModule\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppServerModule { }\n\n// 3. app.component.ts\n@Component({\n  selector: 'app-root',\n  template: `\n    <div>\n      <h1>{{ title }}</h1>\n      <div *ngIf='isBrowser'>Browser only content</div>\n    </div>\n  `\n})\nexport class AppComponent {\n  isBrowser: boolean;\n\n  constructor(@Inject(PLATFORM_ID) platformId: Object) {\n    this.isBrowser = isPlatformBrowser(platformId);\n  }\n}\n\n// 4. Running the application\n// package.json\n{\n  \"scripts\": {\n    \"dev:ssr\": \"ng run my-app:serve-ssr\",\n    \"build:ssr\": \"ng build && ng run my-app:server\",\n    \"serve:ssr\": \"node dist/my-app/server/main.js\"\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 131,
    "question": "What is the difference between AOT and JIT compilation in Angular?",
    "answer": "<p>AOT (Ahead-of-Time) and JIT (Just-in-Time) are two different ways Angular compiles your application.</p><h3>Key Differences:</h3><ul><li>AOT compiles at build time</li><li>JIT compiles at runtime</li><li>AOT is faster and more secure</li><li>JIT is better for development</li></ul><h3>Example:</h3><pre><code>// AOT Compilation (Production)\n// angular.json\n{\n  \"configurations\": {\n    \"production\": {\n      \"aot\": true,\n      \"optimization\": true\n    }\n  }\n}\n\n// JIT Compilation (Development)\n// main.ts\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n// AOT Compilation\n// main.ts\nplatformBrowser().bootstrapModule(AppModule);</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 132,
    "question": "What is the difference between providedIn: 'root' and @NgModule.providers?",
    "answer": "<p>Both approaches provide services in Angular, but they have different scopes and use cases.</p><h3>providedIn: 'root':</h3><ul><li>Singleton service</li><li>Available application-wide</li><li>Tree-shakeable</li></ul><h3>@NgModule.providers:</h3><ul><li>Module-scoped service</li><li>Can have multiple instances</li><li>Not tree-shakeable</li></ul><h3>Example:</h3><pre><code>// Root-level service\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService {\n  // Available everywhere\n}\n\n// Module-level service\n@Injectable()\nexport class ModuleService {\n  // Only available in this module\n}\n\n@NgModule({\n  providers: [ModuleService]\n})\nexport class FeatureModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 133,
    "question": "How do you architect a large-scale Angular application?",
    "answer": "<p>Architecting a large-scale Angular application requires careful planning and organization.</p><h3>Key Principles:</h3><ul><li>Feature modules</li><li>Lazy loading</li><li>Shared modules</li><li>Core module</li><li>State management</li></ul><h3>Example Structure:</h3><pre><code>src/\n  app/\n    core/\n      services/\n      guards/\n      interceptors/\n    shared/\n      components/\n      directives/\n      pipes/\n    features/\n      auth/\n      users/\n      products/\n    app.module.ts\n    app-routing.module.ts\n\n// Core Module\n@NgModule({\n  providers: [\n    AuthService,\n    AuthGuard,\n    HTTP_INTERCEPTORS\n  ]\n})\nexport class CoreModule { }\n\n// Shared Module\n@NgModule({\n  declarations: [\n    SharedComponent,\n    SharedDirective,\n    SharedPipe\n  ],\n  exports: [\n    SharedComponent,\n    SharedDirective,\n    SharedPipe\n  ]\n})\nexport class SharedModule { }</code></pre>",
    "category": "Angular",
    "difficulty": "Advanced"
  },
  {
    "id": 134,
    "question": "What are some commonly used RxJS operators in Angular?",
    "answer": "<p>RxJS operators are used to transform, filter, and combine observables in Angular.</p><h3>Common Operators:</h3><ul><li>map</li><li>filter</li><li>switchMap</li><li>catchError</li><li>debounceTime</li></ul><h3>Example:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent {\n  constructor(private userService: UserService) {}\n\n  // Using map\n  getUsers() {\n    return this.userService.getUsers().pipe(\n      map(users => users.map(user => user.name))\n    );\n  }\n\n  // Using switchMap\n  getUserDetails(id: number) {\n    return this.userService.getUser(id).pipe(\n      switchMap(user => this.userService.getUserDetails(user.id))\n    );\n  }\n\n  // Using debounceTime\n  searchUsers(term: string) {\n    return this.userService.searchUsers(term).pipe(\n      debounceTime(300),\n      distinctUntilChanged()\n    );\n  }\n\n  // Using catchError\n  getData() {\n    return this.userService.getData().pipe(\n      catchError(error => {\n        console.error('Error:', error);\n        return of([]);\n      })\n    );\n  }\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  },
  {
    "id": 135,
    "question": "What is takeUntil in RxJS and how do you use it?",
    "answer": "<p>takeUntil is an RxJS operator used to automatically unsubscribe from observables when a component is destroyed.</p><h3>Usage:</h3><pre><code>@Component({\n  selector: 'app-example',\n  template: '...'\n})\nexport class ExampleComponent implements OnInit, OnDestroy {\n  private destroy$ = new Subject<void>();\n\n  constructor(private userService: UserService) {}\n\n  ngOnInit() {\n    // Using takeUntil\n    this.userService.getUsers()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(users => {\n        // Handle users\n      });\n\n    // Multiple subscriptions\n    this.userService.getData()\n      .pipe(takeUntil(this.destroy$))\n      .subscribe(data => {\n        // Handle data\n      });\n  }\n\n  ngOnDestroy() {\n    this.destroy$.next();\n    this.destroy$.complete();\n  }\n}</code></pre><h3>Alternative Approach:</h3><pre><code>// Using async pipe (preferred)\n@Component({\n  selector: 'app-example',\n  template: `\n    <div *ngIf='users$ | async as users'>\n      <div *ngFor='let user of users'>\n        {{ user.name }}\n      </div>\n    </div>\n  `\n})\nexport class ExampleComponent {\n  users$ = this.userService.getUsers();\n\n  constructor(private userService: UserService) {}\n}</code></pre>",
    "category": "Angular",
    "difficulty": "Intermediate"
  }
]